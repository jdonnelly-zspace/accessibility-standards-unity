using System;
using System.Collections.Generic;
using UnityEngine;

namespace AccessibilityStandardsUnity.Editor
{
    /// <summary>
    /// Data models for parsing accessibility audit JSON reports
    /// Matches the structure generated by bin/audit.js
    /// </summary>

    [Serializable]
    public class AccessibilityAuditReport
    {
        public AuditMetadata metadata;
        public AuditSummary summary;
        public List<SceneInfo> scenes;
        public AuditStatistics statistics;
        public AuditFindings findings;
        public ComplianceEstimate complianceEstimate;
    }

    [Serializable]
    public class AuditMetadata
    {
        public string appName;
        public string projectPath;
        public string scannedDate;
        public string analyzer;
        public string version;
    }

    [Serializable]
    public class AuditSummary
    {
        public int totalScenes;
        public int totalScripts;
        public int totalFindings;
        public int criticalIssues;
        public int highPriorityIssues;
        public int mediumPriorityIssues;
        public int lowPriorityIssues;
    }

    [Serializable]
    public class SceneInfo
    {
        public string name;
        public string path;
        public string fullPath;
    }

    [Serializable]
    public class AuditStatistics
    {
        public int totalScenes;
        public int totalScripts;
        public bool accessibilityComponentsFound;
        public bool screenReaderSupportFound;
        public bool focusIndicatorsFound;
        public bool keyboardSupportFound;
        public List<string> keyboardSupportScripts;
        public List<string> stylusOnlyScripts;
        public bool inputSystemUsed;
        public bool eventSystemConfigured;
        public bool focusManagementFound;
        public float keyboardConfidenceScore;
        public bool uiToolkitFound;
        public int uxmlFilesAnalyzed;
        public int ussFilesAnalyzed;
        public int totalUIElements;
        public int focusableElements;
        public int elementsWithTabIndex;
        public bool tabOrderDefined;
        public float uiToolkitConfidenceScore;
        public bool xrCapabilitiesDetected;
        public List<string> xrSDKsDetected;
        public bool spatialAudioFound;
        public bool alternativeInputFound;
        public bool depthCuesFound;
        public float xrConfidenceScore;
    }

    [Serializable]
    public class AuditFindings
    {
        public List<Finding> critical;
        public List<Finding> high;
        public List<Finding> medium;
        public List<Finding> low;
    }

    [Serializable]
    public class Finding
    {
        public string id;
        public string title;
        public string description;
        public string wcagCriteria;
        public string wcagLevel;
        public string priority;
        public string category;
        public string recommendation;
        public float confidence;
        public string evidence;
        public List<string> affectedFiles;
        public List<int> affectedLines;
    }

    [Serializable]
    public class ComplianceEstimate
    {
        public int score;
        public string level;
        public bool wcagLevelA;
        public bool wcagLevelAA;
    }

    /// <summary>
    /// Helper class for parsing and working with audit reports
    /// </summary>
    public static class AuditDataParser
    {
        /// <summary>
        /// Parse audit report from JSON file
        /// </summary>
        public static AccessibilityAuditReport ParseFromJson(string jsonPath)
        {
            if (!System.IO.File.Exists(jsonPath))
            {
                Debug.LogError($"Audit report not found: {jsonPath}");
                return null;
            }

            try
            {
                string jsonText = System.IO.File.ReadAllText(jsonPath);
                AccessibilityAuditReport report = JsonUtility.FromJson<AccessibilityAuditReport>(jsonText);
                return report;
            }
            catch (Exception ex)
            {
                Debug.LogError($"Failed to parse audit report: {ex.Message}");
                return null;
            }
        }

        /// <summary>
        /// Get finding color based on priority
        /// </summary>
        public static Color GetFindingColor(string priority)
        {
            switch (priority?.ToLower())
            {
                case "critical":
                    return new Color(0.8f, 0.1f, 0.1f); // Red
                case "high":
                    return new Color(0.9f, 0.5f, 0.1f); // Orange
                case "medium":
                    return new Color(0.9f, 0.8f, 0.1f); // Yellow
                case "low":
                    return new Color(0.5f, 0.7f, 1.0f); // Light blue
                default:
                    return Color.gray;
            }
        }

        /// <summary>
        /// Get compliance level color
        /// </summary>
        public static Color GetComplianceColor(int score)
        {
            if (score >= 90)
                return new Color(0.2f, 0.8f, 0.2f); // Green
            else if (score >= 70)
                return new Color(0.9f, 0.8f, 0.1f); // Yellow
            else if (score >= 50)
                return new Color(0.9f, 0.5f, 0.1f); // Orange
            else
                return new Color(0.8f, 0.1f, 0.1f); // Red
        }

        /// <summary>
        /// Format WCAG criteria for display
        /// </summary>
        public static string FormatWCAGCriteria(string wcagCriteria)
        {
            if (string.IsNullOrEmpty(wcagCriteria))
                return "N/A";

            // Format like "WCAG 2.2.1 (Level A)"
            return wcagCriteria.Replace(",", ", ");
        }

        /// <summary>
        /// Get all findings across all priorities
        /// </summary>
        public static List<Finding> GetAllFindings(AuditFindings findings)
        {
            List<Finding> allFindings = new List<Finding>();
            if (findings == null) return allFindings;

            if (findings.critical != null) allFindings.AddRange(findings.critical);
            if (findings.high != null) allFindings.AddRange(findings.high);
            if (findings.medium != null) allFindings.AddRange(findings.medium);
            if (findings.low != null) allFindings.AddRange(findings.low);

            return allFindings;
        }

        /// <summary>
        /// Get findings by category
        /// </summary>
        public static Dictionary<string, List<Finding>> GroupFindingsByCategory(AuditFindings findings)
        {
            Dictionary<string, List<Finding>> grouped = new Dictionary<string, List<Finding>>();
            List<Finding> allFindings = GetAllFindings(findings);

            foreach (Finding finding in allFindings)
            {
                string category = finding.category ?? "Other";
                if (!grouped.ContainsKey(category))
                {
                    grouped[category] = new List<Finding>();
                }
                grouped[category].Add(finding);
            }

            return grouped;
        }
    }
}
